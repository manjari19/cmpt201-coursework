// Lab 8 - Starting Code for sorting data in threads using uthash
#include <pthread.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "uthash.h"

#define THREAD_COUNT 3
typedef const char *word_t;

typedef struct {
    word_t word;
    size_t count;
    UT_hash_handle hh;
} word_count_entry_t;

word_count_entry_t *create_entry(word_t, size_t);

typedef word_count_entry_t *count_map_t;

typedef struct {
    count_map_t *map;
    word_t *words;
    size_t num_words;
    pthread_mutex_t *lock;
} count_thread_args_t;

count_thread_args_t *pack_args(count_map_t *map, word_t *words,
                               size_t num_words, pthread_mutex_t *lock);

static void add_word_counts_in_chunk(count_map_t *map, word_t *words,
                                     size_t num_words, pthread_mutex_t *lock) {
    // --------- Task 4 ---------
    // Make this function thread-safe by using the lock

    for (size_t i = 0; i < num_words; i++) {
        if (lock) pthread_mutex_lock(lock);  // lock each pass
        word_count_entry_t *w = NULL;
        HASH_FIND_STR(*map, words[i], w);

        if (w) {
            w->count++;
        } else {
            w = create_entry(words[i], 1);
            HASH_ADD_STR(*map, word, w);
        }
        if (lock) pthread_mutex_unlock(lock); // unlock each pass
    }
}

static void *counter_thread_func(void *arg) {
    count_thread_args_t *args = (count_thread_args_t *)arg;
    add_word_counts_in_chunk(args->map, args->words, args->num_words, args->lock);
    return NULL;
}

static count_map_t count_words_seq(word_t *words, size_t num_words) {
    count_map_t map = NULL;
    add_word_counts_in_chunk(&map, words, num_words, NULL);
    return map;
}

static count_map_t count_words_parallel(word_t *words, size_t num_words) {
    // --------- Task 2 ---------
    // Implement the parallel version using threads

    count_map_t map = NULL;
    pthread_t threads[THREAD_COUNT];
    count_thread_args_t *threads_args[THREAD_COUNT];
    pthread_mutex_t count_mutex;
    pthread_mutex_init(&count_mutex, NULL);

    size_t chunk = num_words / THREAD_COUNT;
    size_t offset = 0;

    for (int i = 0; i < THREAD_COUNT; i++) {
        size_t this_chunk = (i == THREAD_COUNT - 1) ? (num_words - offset) : chunk;
        threads_args[i] = pack_args(&map, words + offset, this_chunk, &count_mutex);
        offset += this_chunk;

        pthread_create(&threads[i], NULL, counter_thread_func, threads_args[i]);
    }

    for (int i = 0; i < THREAD_COUNT; i++) {
        pthread_join(threads[i], NULL);
        free(threads_args[i]);
    }

    pthread_mutex_destroy(&count_mutex);
    return map;
}

int sort_func(const word_count_entry_t *a, const word_count_entry_t *b) {
    return strcmp(a->word, b->word);
}

void print_word_counts(count_map_t word_map) {
    printf("%-30s %s\n", "Word", "Count");

    word_count_entry_t *current, *tmp;
    HASH_ITER(hh, word_map, current, tmp) {
        printf("%-30s %zu\n", current->word, current->count);
    }
}

void free_word_counts(count_map_t word_map) {
    word_count_entry_t *current, *tmp;
    HASH_ITER(hh, word_map, current, tmp) {
        HASH_DEL(word_map, current);
        free((char *)current->word);
        free(current);
    }
}

word_count_entry_t *create_entry(word_t word, size_t count) {
    word_count_entry_t *entry = malloc(sizeof(word_count_entry_t));
    entry->word = strdup(word);
    entry->count = count;
    return entry;
}

count_thread_args_t *pack_args(count_map_t *map, word_t *words,
                               size_t num_words, pthread_mutex_t *lock) {
    count_thread_args_t *args = malloc(sizeof(count_thread_args_t));
    args->map = map;
    args->words = words;
    args->num_words = num_words;
    args->lock = lock;
    return args;
}

int main() {
    // --------- Task 0 ---------
    // Read through this code to understand how it runs

    word_t words[] = {
        "the", "quick", "brown", "fox", "jumps", "over", "the", "lazy", "dog",
        "the", "quick", "brown", "fox", "the"};
    size_t num_words = sizeof(words) / sizeof(words[0]);

    // --------- Task 1 ---------
    // Sort the table before printing

    // count_map_t word_map = count_words_seq(words, num_words);
    count_map_t word_map = count_words_parallel(words, num_words);

    HASH_SORT(word_map, sort_func); // added for Task 1
    print_word_counts(word_map);
    free_word_counts(word_map);

    return 0;
}

